
#!/usr/bin/env python

# pyinfra
# File: bin/pyinfra
# Desc: __main__ for pyinfra

'''
pyinfra

Usage:
    pyinfra -i INVENTORY DEPLOY [options] [-v | -vv]
    pyinfra -i INVENTORY --fact FACT [options] [-v]
    pyinfra (--facts | --help | --version)

Options:
    DEPLOY               Deploy script filename.
    -i INVENTORY         Inventory script filename or single hostname.
    --limit HOSTNAME     Limit the inventory at runtime, supports *wildcards.
    --serial             Run commands on one host at a time.
    --nowait             Don't wait for all hosts at each operation.
    -v                   Prints remote input/output in realtime. -vv prints facts.
    --dry                Only print proposed changes.
    --fact FACT          Name of fact to run/test.
    -p --port PORT#      SSH port number.
    -u --user USER       SSH user.
    --key KEY_FILE       SSH private key.
    --key-password PASS  SSH key password.
    --sudo               Use sudo.
    --sudo-user USER     Which user to sudo to.
    --debug              Print debug info.
    --dir DEPLOY_DIR     Sets the directory to look for group_data/files/etc.
'''

from __future__ import division

from gevent import monkey
monkey.patch_all()

import sys
import json
import signal
import logging
from os import path

from docopt import docopt
from termcolor import colored
from coloredlogs import ColoredStreamHandler

from pyinfra import host, logger, state as pseudo_state
from pyinfra.cli import (
    make_inventory, load_config,
    print_meta, print_results,
    json_encode, run_hook
)

from pyinfra.api import State
from pyinfra.api.ssh import connect_all
from pyinfra.api.operations import run_ops
from pyinfra.api.attrs import FallbackAttrData
from pyinfra.api.facts import facts, get_facts, set_print_facts
from pyinfra.api.exceptions import PyinfraException


# Handle ctrl+c
def signal_handler(signum, frame):
    print 'Exiting upon user request!'
    sys.exit(0)

signal.signal(signal.SIGINT, signal_handler)


# Setup arguments
arguments = docopt(__doc__, version='pyinfra')
arguments = {
    'inventory': arguments['-i'],
    'deploy': arguments['DEPLOY'],
    'verbose': arguments['-v'],
    'dry': arguments['--dry'],
    'serial': arguments['--serial'],
    'nowait': arguments['--nowait'],
    'debug': arguments['--debug'],
    'fact': arguments['--fact'],
    'limit': arguments['--limit'],
    'list_facts': arguments['--facts'],
    'deploy_dir': arguments['--dir'],
    'user': arguments['--user'],
    'key': arguments['--key'],
    'key_password': arguments['--key-password'],
    'port': arguments['--port'],
    'sudo': arguments['--sudo'],
    'sudo_user': arguments['--sudo-user']
}

print_output = arguments['verbose'] > 0
print_facts = print_output if arguments['deploy'] is None else arguments['verbose'] > 1
set_print_facts(print_facts, print_output)

# Setup logs
logging.getLogger().setLevel(logging.CRITICAL)
log_level = logging.DEBUG if arguments['debug'] else logging.INFO
color_args = {
    'show_timestamps': False,
    'show_hostname': False,
    'show_name': False
}
handler = ColoredStreamHandler(level=log_level, **color_args)
logger.setLevel(log_level)
logger.addHandler(handler)


print
print '-> Welcome to pyinfra'
print


# Quickly list facts & exit if desired
if arguments['list_facts']:
    logger.info('Available facts list:')
    print json.dumps(facts.keys(), indent=4)
    sys.exit(0)


# Now we're doing some work, either a dry or real run
try:
    # Setup our "working directory", taking --dir as default
    if arguments['deploy_dir']:
        deploy_dir = arguments['deploy_dir']

    # This is the most common case: we have a deploy file so use it's pathname
    elif arguments['deploy'] is not None:
        deploy_dir = path.dirname(arguments['deploy'])

    # Load up the inventory from the filesystem
    inventory, inventory_group = make_inventory(
        arguments['inventory'],
        deploy_dir=deploy_dir,
        limit=arguments['limit'],
        ssh_user=arguments['user'],
        ssh_key=arguments['key'],
        ssh_key_password=arguments['key_password'],
        ssh_port=arguments['port']
    )

    # Load up any config.py from the filesystem
    config = load_config(deploy_dir)
    # Arg based overrides
    if arguments['sudo']:
        config.SUDO = True
        if arguments['sudo_user']:
            config.SUDO_USER = arguments['sudo_user']

    # Create/set the state
    state = State(inventory, config)
    state.deploy_dir = deploy_dir
    pseudo_state.set(state)

    # Setup the data to be passed to config hooks
    hook_data = FallbackAttrData(
        state.inventory.get_group_data(inventory_group),
        state.inventory.get_data(),
        state.inventory.get_default_data()
    )

    # Run the before_connect hook if provided
    run_hook(state, config, 'before_connect', hook_data)

    # Connect to all the servers
    logger.info('Connecting to hosts...')
    connect_all(state)

    # Check we've connected to something
    n_connected_hosts = len(state.inventory.connected_hosts)
    if n_connected_hosts == 0:
        raise PyinfraException('No hosts connected, exiting')

    # Check we've not failed
    if state.config.FAIL_PERCENT is not None:
        percent_failed = (1 - n_connected_hosts / len(state.inventory)) * 100
        if percent_failed >= state.config.FAIL_PERCENT:
            raise PyinfraException('Over {0}% of hosts failed, exiting'.format(
                state.config.FAIL_PERCENT
            ))

    print

    # No deploy file, we're getting a fact
    if arguments['deploy'] is None:
        if ':' in arguments['fact']:
            fact, arg = arguments['fact'].split(':')
        else:
            fact = arguments['fact']
            arg = None

        fact_data = get_facts(
            fact, arg=arg,
            sudo=arguments['sudo'], sudo_user=arguments['sudo_user'],
            print_output=print_output
        )
        print json.dumps(fact_data, indent=4, default=json_encode)

        sys.exit(0)

    # We're building a deploy!
    logger.info('Building deploy scripts...')

    # This actually does the op build
    for host_obj in inventory:
        host.set(host_obj)
        execfile(arguments['deploy'])
        logger.info('{0} {1}'.format(
            '[{}]'.format(colored(host_obj.ssh_hostname, attrs=['bold'])),
            colored('Ready', 'green')
        ))

    # Always show meta output
    print
    logger.info('Proposed changes:')
    print_meta(state)

    # Not running the op?
    if arguments['dry']:
        if print_output:
            print
            logger.info('Proposed operations:')
            print json.dumps(state.ops, indent=4, default=json_encode)
            print
            logger.info('Operation meta:')
            print json.dumps(state.op_meta, indent=4, default=json_encode)
            print
            logger.info('Operation order:')
            print json.dumps(state.op_order, indent=4, default=json_encode)

    # Run the operations we generated with the deploy file
    else:
        print

        # Run the before_deploy hook if provided
        run_hook(state, config, 'before_deploy', hook_data)

        logger.info('Beginning operation run...')
        run_ops(
            state,
            serial=arguments['serial'],
            nowait=arguments['nowait'],
            print_output=print_output,
            print_lines=True
        )

        # Run the after_deploy hook if provided
        run_hook(state, config, 'after_deploy', hook_data)

        logger.info('Results:')
        print_results(state)

except PyinfraException as e:
    logger.critical(e)


print
print '<- Thank you, goodbye'
print

sys.exit(0)
